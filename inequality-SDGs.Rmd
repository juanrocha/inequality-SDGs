---
title: "SDGs"
author: "Juan Rocha"
date: "Updated `r Sys.Date()`"
output:
  html_notebook:
    toc: yes
    toc_float: yes
    highlight: tango
    code_folding: hide
    df_print: paged
    theme: 
      bootswatch: cosmo
      code_font:
        google: Fira Code
editor_options: 
  chunk_output_type: inline
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(
  cache = TRUE, warning = FALSE, message = FALSE, echo = TRUE,
  fig.width = 8, fig.height = 5
)


library(tidyverse)
library(naniar)
library(plotly)
library(patchwork)

# time series
library(tsibble)
library(fable)
library(imputeTS)
library(slider)

# # clustering
# library(vegan)
# library(NbClust)
# library(clValid)
# library(mclust)

#theme_set(theme_light(base_size = 12))
```

This notebooks explores synergies and trade-offs between inequality and other SDGs with the World Bank dataset on sustainable development goals at the national scale.

## World Bank SDGs

```{r}
dat <- read_csv(file = "~/Documents/Projects/DATA/WorldBank/SDG_csv/SDGData.csv") |> 
    janitor::clean_names()

dat
```
```{r}
# key <- read_csv(
#     file = "~/Documents/Projects/DATA/WorldBank/SDG_csv/SDGSeries.csv"
# ) |> janitor::clean_names()
key <- googlesheets4::read_sheet(
    "https://docs.google.com/spreadsheets/d/1T6rZ5T1qL4BPDL5oatMf3y8lLzhnIDvxIvkbJeBkdUc/edit?usp=sharing", sheet = 1
)

key <- key |> janitor::clean_names()
key |> pull(topic) |> unique()

countries <- read_csv(
    file = "~/Documents/Projects/DATA/WorldBank/SDG_csv/SDGCountry.csv") |> 
    janitor::clean_names()

countries_list <- countries |> filter(!is.na(currency_unit)) |> pull(country_code)
## correct Namibia, it is not an NA in x2_alpha_code

countries$x2_alpha_code[countries$country_code == "NAM"] <- "NA"

```

```{r}
dat$indicator_name |> unique() |> length()
```
Extract environmental variables only

```{r}
# env_topics <- key$topic |> str_subset("Environment")
# 
# env_vars <- key |> 
#     filter(topic %in% env_topics) |> 
#     pull(indicator_name) |> 
#     unique()
maike_vars <- key |> 
    filter(!is.na(maike_selection)) |> 
    pull(indicator_name) |> 
    unique()
```

```{r}
n_countries <- dat |> filter(country_code %in% countries_list) |> 
    pull(country_code) |> unique() |> length()

p <- dat |>
    filter(indicator_name %in% maike_vars, country_code %in% countries_list) |> 
    select(-x35) |> 
    pivot_longer(cols = x1990:last_col(), values_to = "value", names_to = "year") |> 
    mutate(year = str_remove(year, "x"), year = as.numeric(year)) |> 
    group_by(indicator_name, year) |> 
    mutate(nas = is.na(value)) |> 
    summarise(missing = sum(nas) / n_countries) |> 
    ggplot(aes(year, indicator_name)) +
    geom_tile(aes(fill = missing)) +
    scale_fill_viridis_c(
        guide = guide_colorbar(barwidth = unit(2,"mm"), barheight = unit(20, "mm"))) + 
    labs(x = "Year", y = "Indicator name") +
    theme_light(base_size = 6)
# 
# ggsave(
#     plot = p, filename = "WB_environment_SDGs.png", path = "figures/", device = "png",
#     width = 6, height = 4, dpi = 400, bg = "white"
# )

p + theme_light(base_size = 8)
```

```{r}
other_vars <- key |> 
    filter(!is.na(include)) |> 
    pull(indicator_name) |> 
    unique()

p <- dat |>
    filter(indicator_name %in% other_vars, country_code %in% countries_list) |> 
    select(-x35) |> 
    pivot_longer(cols = x1990:last_col(), values_to = "value", names_to = "year") |> 
    mutate(year = str_remove(year, "x"), year = as.numeric(year)) |> 
    group_by(indicator_name, year) |> 
    mutate(nas = is.na(value)) |> 
    summarise(missing = sum(nas) / n_countries) |> 
    ggplot(aes(year, indicator_name)) +
    geom_tile(aes(fill = missing)) +
    scale_fill_viridis_c(
        guide = guide_colorbar(barwidth = unit(2,"mm"), barheight = unit(20, "mm"))) + 
    labs(x = "Year", y = "Indicator name") +
    theme_light(base_size = 6)

p + theme_light(base_size = 8)

# ggsave(
#     plot = p, filename = "WB_environment_SDGs_othervars.png", path = "figures/", device = "png",
#     width = 6, height = 4, dpi = 400, bg = "white"
# )
```


And the inequality variables

```{r}
# ineq_topics <- c("Financial Sector: Access", ) 

key$topic |> unique()
```

## To-dos

**Wait until Maike and Tong revise the selection of variables.** Take the analysis from there. Alternatively, select a couple of topics as example, just to explore how to deal with missing values and what is doable. Once one take missing values into account, the number of variables and countries get reduced quickly.

Combining both options:

```{r}
other_vars <- key |> 
    filter(!is.na(include) | !is.na(maike_selection)) |> 
    pull(indicator_name) |> 
    unique()

p <- dat |>
    filter(indicator_name %in% other_vars, country_code %in% countries_list) |> 
    select(-x35) |> 
    pivot_longer(cols = x1990:last_col(), values_to = "value", names_to = "year") |> 
    mutate(year = str_remove(year, "x"), year = as.numeric(year)) |> 
    group_by(indicator_name, year) |> 
    mutate(nas = is.na(value)) |> 
    summarise(missing = sum(nas) / n_countries) |> 
    ungroup() |> group_by(indicator_name) |> 
    summarize(mean_missing = mean(missing)) |> 
    filter(mean_missing < 0.3) |> 
    ggplot(aes(mean_missing, indicator_name)) +
    geom_point() +
    #scale_fill_viridis_c(
    #    guide = guide_colorbar(barwidth = unit(2,"mm"), barheight = unit(20, "mm"))) + 
    labs(x = "Mean proportion of missing values across countries", y = "Indicator name", tag = "A")+
    theme_light(base_size = 6)

#p + theme_light(base_size = 8)

vars <- p$data$indicator_name

q <- dat |>
    filter(indicator_name %in%  vars) |>
    select(-x35) |>
    pivot_longer(cols = x1990:last_col(), values_to = "value", names_to = "year") |>
    mutate(year = str_remove(year, "x"), year = as.numeric(year)) |>
    mutate(nas = is.na(value)) |>
    filter(year >= 2000, year < 2019) |>  # restricting time improves
    group_by(country_code, indicator_name) |>
    summarise(missing = sum(nas) / diff(range(year))) |>
    #filter(country_code %in% complete_countries) |> # this line only if next cell already run
    # ungroup() |> group_by(country_code) |>
    # summarize(mean_missing = mean(missing)) |>
    #filter(mean_missing < 0.3) |>
    ggplot(aes(country_code, indicator_name)) +
    geom_tile(aes(fill = missing)) +
    scale_fill_viridis_c(
        "Proportion of missing values",
        guide = guide_colorbar(barwidth = unit(2,"cm"), barheight = unit(2,"mm"))) + 
    labs(x = "Country code", y = "Indicator name", tag = "B") +
    theme_light(base_size = 6) +
    theme(axis.text.x = element_text(angle = 90, size = 3), 
          legend.position = "bottom")

p/q
# ggsave(
#     plot = p/q, filename = "WB_selected_vars.png", path = "figures/", device = "png",
#     width = 7, height = 7, dpi = 400, bg = "white"
# )

```
 
```{r}
complete_countries <-  dat |>
    filter(indicator_name %in%  vars) |>
    select(-x35) |>
    pivot_longer(cols = x1990:last_col(), values_to = "value", names_to = "year") |>
    mutate(year = str_remove(year, "x"), year = as.numeric(year)) |>
    mutate(nas = is.na(value)) |>
    filter(year >= 2000, year < 2019) |>  # restricting time improves
    group_by(country_code, indicator_name) |>
    summarise(missing = sum(nas) / diff(range(year))) |> 
    # filter out any country with missing values higher than 70%
    filter(!any(missing > 0.3)) |> 
    pull(country_code) |> unique()

complete_countries
```


Using `tsibble`:

```{r}

dat |>
    filter(indicator_name %in% vars, country_code %in% complete_countries) |> 
    select(-x35) |> 
    pivot_longer(cols = x1990:last_col(), values_to = "value", names_to = "year") |> 
    mutate(year = str_remove(year, "x")) |>  ## Formating for year-month-day
    #mutate(year = lubridate::parse_date_time(year, orders = "Y", select_formats = "%Y"))  |> 
    #mutate(year = strptime(year, format = "%Y")) |>
    mutate(year = lubridate::make_date(year = year)) |> 
    as_tsibble(key = c(country_code, indicator_name), index=year, regular = TRUE) 
    # count_gaps()

```

**J230226:** If I add Gini for inequality from the inequality database, our available countries will drop down to 50+, which is what we did in the trilemma paper. It is risky talking about inequality wihtout Gini because the variables selected are not necessarily interpretable as inequality, but let's see what the group supports.

**J230323** Team recommended only to use inequality on UN Data which is available for ~50+ countries. Check newer dataset from WIID

```{r}
load("data/wii_small-data.RData")
```

```{r}
ineq_dat
```
`m` is total, `a` is average. All other codes are documented here: [https://wid.world/codes-dictionary/#packages](https://wid.world/codes-dictionary/#packages). 

### Correlations

Probably need to log-transform cereal yield and forest area. 

```{r warnings=FALSE, message=FALSE}
crg <- dat |>
    filter(indicator_name %in% vars, country_code %in% complete_countries) |> 
    select(-x35) |> 
    pivot_longer(cols = x1990:last_col(), values_to = "value", names_to = "year") |> 
    mutate(year = str_remove(year, "x"), year = as.numeric(year)) |> 
    filter(year >= 2000, year < 2019) |>  # restricting time improves
    select(-indicator_code) |> 
    pivot_wider(values_from = value, names_from = indicator_name) |> 
    GGally::ggpairs(
        columns = 4:12 ,
    lower = list(continuous = GGally::wrap("points", alpha = 0.5, size = 0.5)),
    diag = list(continuous = GGally::wrap("densityDiag", alpha = 0.2))
    # upper = list(continuous = GGally::wrap("cor", size = 2))
    ) + theme_light(base_size = 4)

crg

# ggsave(
#     plot = crg, filename = "WB_correlogram.png", path = "figures/", device = "png",
#     width = 7, height = 7, dpi = 400, bg = "white"
# )
```
Interpolate missing values

```{r}
df_dat <- dat |>
    filter(indicator_name %in% vars, country_code %in% complete_countries) |> 
    select(-x35) |> 
    pivot_longer(cols = x1990:last_col(), values_to = "value", names_to = "year") |> 
    mutate(year = str_remove(year, "x"), year = as.numeric(year)) |> 
    filter(year >= 2000, year < 2019) |>  # restricting time improves
    select(-indicator_code) |> 
    pivot_wider(values_from = value, names_from = indicator_name) %>% 
    group_by(country_code) %>% 
    mutate(across(.cols = vars, .fns = na_interpolation, option = "spline")) 

df_dat |> ungroup() |> skimr::skim() # no missing values
```

```{r}
## both datasets are wider format, so makes sense to merge as is
df_dat <- df_dat |>
    left_join(countries |> select(country_code, country = x2_alpha_code)) |> 
    left_join(ineq_dat |> 
                  select(-age, -pop) |> 
                  unite(col = "var", c("variable", "percentile")) |> 
                  pivot_wider(names_from = var, values_from = value)
              )
```


## UN SDGs

```{r}
un_countries <- read_csv2(file = "~/Documents/Projects/DATA/SDGs_UNStats/UNSD — Methodology.csv")
sdg <- read_csv(file = "~/Documents/Projects/DATA/SDGs_UNStats/20180817102044132_juan.rocha@su.se_data.csv") |> janitor::clean_names()

sdg <- sdg |> 
    left_join(
        select(un_countries, country = `Country or Area`, starts_with("ISO")),
        by = c("geo_area_name" = "country")) |> 
    filter(value != "-")|> 
    mutate(value = as.numeric(value))

sdg 
```

Why are there more than one obs per country per year per indicator???
```{r}
sdg |> 
    filter(`ISO-alpha3 Code` %in% countries_list) |> 
    group_by(geo_area_code, indicator, time_period) |> 
    summarize(n = n()) |> 
    filter(n>19) |>  # 19 is the max number of years
    arrange(desc(n)) #|> pull(geo_area_code) |> unique() # 191 countries (all of them)

sdg |> 
    filter(geo_area_code == 40, indicator == "5.4.1", time_period == 2009)

```
Answer: there are indicators that are calculated per age group, sex and rural / urban divide. They need to be processed to a single number per year. To discuss options:

- What dimension to use?: gender, age, rural / urban / all
- What summary statistic to use: mean, var, gini?

```{r}
n_countries2 <- sdg |> 
    filter(`ISO-alpha3 Code` %in% countries_list) |>
    pull(geo_area_name) |> unique() |> length() # number of countries, but here are also non-countries categories like continents, etc.

a <- sdg |> 
    rename(indicator_name = series_description, year = time_period, iso3 =`ISO-alpha3 Code` ) |> 
    filter(iso3 %in% countries_list, !is.na(value)) |> # use only countries
    filter(goal == 10) |> 
    group_by(indicator, indicator_name, year, iso3) |> 
    summarize(mean_val = mean(value, na.rm = TRUE)) |> 
    pivot_wider(names_from = year, values_from = mean_val) |> 
    pivot_longer(cols = starts_with("2"), names_to = "year", values_to = "value",
                 names_transform = list(year = as.numeric, value = as.numeric)) |> 
    mutate(nas = is.na(value)) |> 
    group_by(indicator_name, year) |> 
    summarise(missing = sum(nas) / n_countries2) |> 
    ggplot(aes(year, indicator_name)) +
    geom_tile(aes(fill = missing)) +
    scale_fill_viridis_c(
        "Missing",
        guide = guide_colorbar(barheight = unit(2,"cm"), barwidth = unit(2,"mm"))) + 
    labs(title = "SDG10: Inequality indicators", 
         x = "Year", y = "Indicator name", tag = "A") +
    theme_light(base_size = 6)
a
# sdg |> 
#     filter(series_description == "Proportion of voting rights of developing countries in international organizations, by organization (%)")

```

```{r}
b <- sdg |> 
    rename(indicator_name = series_description, year = time_period, iso3 =`ISO-alpha3 Code` ) |> 
    filter(iso3 %in% countries_list, !is.na(value)) |> # use only countries
    filter(goal == 14) |> 
    group_by(indicator, indicator_name, year, iso3) |> 
    summarize(mean_val = mean(value, na.rm = TRUE)) |> 
    pivot_wider(names_from = year, values_from = mean_val) |> 
    pivot_longer(cols = starts_with("2"), names_to = "year", values_to = "value",
                 names_transform = list(year = as.numeric, value = as.numeric)) |> 
    mutate(nas = is.na(value)) |> 
    group_by(indicator_name, year) |> 
    summarise(missing = sum(nas) / n_countries2) |> 
    ggplot(aes(year, indicator_name)) +
    geom_tile(aes(fill = missing)) +
     scale_fill_viridis_c(
        "Missing",
        guide = guide_colorbar(barheight = unit(2,"cm"), barwidth = unit(2,"mm"))) +
    labs(title = "SDG14: Life under water", x = "Year", y = "Indicator name", tag = "B") +
    theme_light(base_size = 6)
b
```

```{r}
c <- sdg |> 
    rename(indicator_name = series_description, year = time_period, iso3 =`ISO-alpha3 Code` ) |> 
    filter(iso3 %in% countries_list, !is.na(value)) |> # use only countries
    filter(goal == 15) |> 
    group_by(indicator, indicator_name, year, iso3) |>
    summarize(mean_val = mean(value, na.rm = TRUE)) |>
    pivot_wider(names_from = year, values_from = mean_val) |> 
    pivot_longer(cols = starts_with("2"), names_to = "year", values_to = "value",
                 names_transform = list(year = as.numeric, value = as.numeric)) |> 
    mutate(nas = is.na(value)) |> 
    group_by(indicator, indicator_name, year) |> 
    summarise(missing = sum(nas) / n_countries2) |> 
    mutate(indicator_name = str_trunc(indicator_name, width = 100, side = "right")) |>
    ggplot(aes(year, indicator_name)) +
    geom_tile(aes(fill = missing)) +
    scale_fill_viridis_c("Missing",
        guide = guide_colorbar(barheight = unit(2,"cm"), barwidth = unit(2,"mm"))) +
    labs(title = "SDG15: Life on land", x = "Year", y = "Indicator name", tag = "C") +
    theme_light(base_size = 6)
c

## Very long names:
sdg |> 
    rename(indicator_name = series_description, year = time_period, iso3 =`ISO-alpha3 Code` ) |> 
    filter(iso3 %in% countries_list, !is.na(value)) |> # use only countries
    filter(goal == 15) |> 
    select(indicator, indicator_name) |> 
    unique()

# ggsave(
#     plot = a/b/c, filename = "UN_selected_vars.png", path = "figures/", device = "png",
#     width = 7, height = 7, dpi = 400, bg = "white"
# )

```

Usable variables from UN Dataset:

```{r}
p2 <- sdg |> 
    rename(series_name = series_description, year = time_period, iso3 =`ISO-alpha3 Code` ) |> 
    filter(iso3 %in% complete_countries) |> # use only countries
    filter(goal %in% c(10, 14, 15)) |> 
    group_by(series_name, year, iso3) |>
    # this gets rid of multiple values per year
    summarize(mean_val = mean(value, na.rm = TRUE)) |> 
    # add_count() |> 
    pivot_wider(names_from = year, values_from = mean_val) |> 
    pivot_longer(cols = starts_with("2"), names_to = "year", values_to = "value",
                 names_transform = list(year = as.numeric, value = as.numeric)) |> 
    mutate(nas = is.na(value)) |> 
    ungroup() |> group_by(series_name, iso3) |> 
   # group_by(indicator, indicator_name, iso3) |> 
    summarise(missing = sum(nas) / diff(range(year)) ) |>  ## dividing by number of years (per country)
    #pull(missing) |> range() # should be between 0-1
    # summarize(mean_missing = mean(missing)) |> 
    filter(missing < 0.3) |> 
    ungroup() |> 
    pivot_wider(names_from = series_name, values_from = missing) |> 
    pivot_longer(cols = `Average proportion of Freshwater Key Biodiversity Areas (KBAs) covered by protected areas (%)`:last_col(), names_to = "series_name",
                 values_to = "missing") |> 
    group_by(series_name) |> 
    #filter(!any(is.na(missing))) |> 
    # ggplot(aes(iso3, series_name)) +
    # geom_tile(aes(fill = missing)) +
    # theme_light()
    summarize(missing_countries = sum(is.na(missing))) |> 
    filter(missing_countries < 45) |> 
    ggplot(aes(missing_countries, series_name))+
    geom_point() +
    labs(tag = "A", y = "Series name", x = "Proportion of missing countries") +
    theme_light(base_size = 6)
p2
vars2 <- p2$data$series_name
```

```{r}
q2 <- sdg |> 
    rename(series_name = series_description, year = time_period, iso3 =`ISO-alpha3 Code` ) |> 
    filter(iso3 %in% complete_countries) |> # use only countries
    filter(series_name %in% vars2) |> 
    ## this line is to get rid of multiple values per year
    group_by(series_name, year, iso3) |>
    summarize(mean_val = mean(value, na.rm = TRUE)) |> 
    ungroup() |> #group_by(indicator_name, year, iso3) |> 
    # add_count() |> 
    pivot_wider(names_from = year, values_from = mean_val) |> 
    pivot_longer(cols = starts_with("2"), names_to = "year", values_to = "value",
                 names_transform = list(year = as.numeric, value = as.numeric)) |> 
    mutate(nas = is.na(value)) |> 
    group_by(series_name, iso3) |> 
    summarise(missing = sum(nas) / diff(range(year))) |>  ## dividing by number of years (per country)
    # summarize(mean_missing = mean(missing)) |> 
    ungroup() |> 
    filter(missing < 0.3) |> 
    ## add missing values again for combination of indicator country:
    ungroup() |> group_by(series_name) |>
    pivot_wider(names_from = iso3, values_from = missing) |> 
    pivot_longer(cols = AFG:last_col(), names_to = "iso3", values_to = "missing") |>
    ## completely empty time series
    #summarize(absent_countries = sum(is.na(missing))) |> 
    ungroup() |> group_by(iso3 ) |> 
    #filter(sum(is.na(missing)) < 45) |> # remove absent_countries > 45
    filter(!any(is.na(missing))) |> 
    ggplot(aes(iso3, series_name)) +
    #geom_point()
    geom_tile(aes(fill = missing)) +
    scale_fill_viridis_c("Missing",
        guide = guide_colorbar(barwidth = unit(2,"mm"), barheight = unit(2,"cm"))) +
    labs(tag = "B", y = "Series name", x = "Countries") +
    theme_light(base_size = 6) +
    theme(axis.text.x = element_text(angle = 90))

q2

complete_countries_sdg <- q2$data$iso3 |> unique()

# ggsave(
#     plot = p2/q2, filename = "UN_reduced_vars.png", path = "figures/", device = "png",
#     width = 7, height = 7, dpi = 400, bg = "white"
# )

```

Reduce the dataset to variables and countries with almost complete data. Then impute missing values.

```{r}
df_un_reduced <- sdg |> 
    rename(series_name = series_description, year = time_period, iso3 =`ISO-alpha3 Code` ) |> 
    filter(iso3 %in% complete_countries_sdg) |> # use only countries
    filter(series_name %in% vars2) |> 
    group_by(series_name, year, iso3) |>
    summarize(mean_val = mean(value, na.rm = TRUE)) |> 
    ungroup() |> 
    pivot_wider(names_from = year, values_from = mean_val) |> 
    pivot_longer(cols = starts_with("2"), names_to = "year", values_to = "value",
                 names_transform = list(year = as.numeric, value = as.numeric)) |> 
    group_by(iso3, series_name) |> 
    mutate(value = na_interpolation(value, option = "spline"))

df_un_reduced |> ungroup() |> skimr::skim() # zero missing values
```

```{r}
crg <- df_un_reduced |> 
    mutate(series_name = str_replace(series_name, "Biodiversity", "Biodiversity\n"),
           series_name = str_replace(series_name, "verified", "verified\n")) |> 
    pivot_wider(values_from = value, names_from = series_name) |> 
    GGally::ggpairs(
        columns = 3:8,
    lower = list(continuous = GGally::wrap("points", alpha = 0.5, size = 0.5)),
    diag = list(continuous = GGally::wrap("densityDiag", alpha = 0.2))
    # upper = list(continuous = GGally::wrap("cor", size = 2))
    ) + theme_light(base_size = 4)

crg

# ggsave(
#     plot = crg, filename = "UN_correlogram.png", path = "figures/", device = "png",
#     width = 7, height = 7, dpi = 400, bg = "white"
# )
```

Merge with WID inequality data:

```{r}

df_un_reduced <- df_un_reduced |> ungroup() |> #group_by(iso3)
    left_join(
        countries |> select(iso3 = country_code, country = x2_alpha_code) ) |> 
    # filter(is.na(country)) |> pull(iso3) |> unique()
    unite(col = "var", year, series_name, sep = "_") |> 
    pivot_wider(values_from = value, names_from = var) |> 
    left_join(
        ineq_dat |> 
            select(-age, -pop) |> 
            filter(year >=  2000, year < 2019) |> # max year 2018 in UN dataset
            unite(col = "series_name", c("variable", "percentile")) |> 
            right_join(
                countries |> 
                    select(iso3 = country_code, country = x2_alpha_code) |> 
                    filter(iso3 != "CHI") # filter out channel islands
            ) |> 
            unite(col = "var", year, series_name, sep = "_") |> 
            pivot_wider(values_from = value, names_from = var) 
        )
```



Now there is two working datasets cleaned and complete: `df_dat` is the data from World Bank, and `df_un_reduced` is the data from UN SDGs.

```{r}
#save(df_dat, df_un_reduced, file = "data/cleaned_sdg.RData")
```


## Notes:

1. Select the variables for which you have time series. Repeat the trajectories analysis. 
2. Do static analysis with all SDGs

Clean up a bit:

```{r}
rm(df_sdg, df_un, df_wb, maike_vars, other_vars, ineq_dat)
# key files
# sdg raw data from UN SDG
# dat raw data from WorldBank
load("data/cleaned_sdg.RData")
```


## Ordination

Following Ingo's advise, here I run a PCA with each variable_year as variable.

```{r}
pca1 <- df_dat |> 
    select(-country_name, -country, -sptinc992j_p0p100) |> 
    filter(!is.na(rptinc992j_p0p100)) |> 
    pivot_longer(cols = `Access to electricity (% of population)`:last_col(),
                 values_to = "value", names_to = "variable") |> 
    unite(col = "var", year, variable, sep = "_") |> 
    pivot_wider(names_from = var, values_from = value) |> 
    ungroup() |> 
    select(-country_code) |> 
    prcomp(center = TRUE, scale. = TRUE)
```



PCA
```{r}
plot(pca1)
```

```{r}
# some notes on the pca object
pca1$rotation |> dim() # 171 variables*years, 160 PCs because there was 160 countries to start with.
pca1$x |> dim() # The loadings of 160 countries in each of the 160 components.
pca1$center |> length() # 171 variable centers
pca1$scale |> length() # 171 variable scales.
```


```{r}
p <- pca1$rotation |> 
    as_tibble(rownames = "vars") |> 
    separate(vars, sep = "_", into = c("year", "variable")) |> 
    mutate(year = as.numeric(year)) |> 
    pivot_longer(cols = starts_with("PC"), names_to = "PC", values_to = "load") |> 
    mutate(PC = str_remove(PC, "PC"), PC = as.numeric(PC)) |> 
    filter(PC < 5) |> 
    ggplot(aes(year, load)) +
    geom_line(aes(color = variable)) +
    facet_wrap(~PC) +
    theme_light(base_size = 8)

# ggsave(
#     plot = p, file = "pca-wb-time.png", path = "figures/", device = "png",
#     width = 7, height = 4, bg = "white", dpi = 400
# )
p + scale_color_brewer(palette = "Set3")
```



```{r}
biplot(pca1, var.axes = FALSE)
```

```{r}
x <- summary(pca1, loadings = F, cutoff = 0.1)
x <- x$importance |> as_tibble(rownames = "var") |> 
    pivot_longer(cols = starts_with("PC"), names_to = "comp") |> 
    mutate(comp = str_remove(comp, "PC") |> as.numeric()) |> 
    dplyr::filter( comp <= 10 , var != "Standard deviation")
    
ggplot(data = x |> filter(var == "Proportion of Variance"), aes(comp, value)) +
    geom_col(color = "grey25") +
    geom_point(data = x |> filter(var == "Cumulative Proportion"), aes(comp, value)) +
    geom_line(data = x |> filter(var == "Cumulative Proportion"), aes(comp, value)) +
    labs(x = "Principal components", y = "Explained variance") +
    scale_x_continuous(n.breaks = 10) +
    scale_y_continuous(labels = scales::label_percent()) +
    theme_light(base_size = 6)

a <- pca1$x |> as_tibble() |> 
    select(PC1:PC2) |> 
    mutate(iso = df_dat |> 
               filter(!is.na(rptinc992j_p0p100)) |>
               pull(country_code) |> unique()) |> 
    ggplot(aes(PC1, PC2)) +
    geom_text(aes(label = iso), size = 2) +
    coord_equal() +
    theme_light(base_size = 6)

b <- ggplot() +
    geom_segment(
        data = pca1$rotation |>
            as_tibble(rownames = "factor") |> 
            mutate(year = str_sub(factor, start = 1L, end = 4L),
                   factor = str_remove(factor, pattern = "\\d{4}_"))  |> 
            select(year, factor, PC1:PC2),
        aes(xend = PC1, yend = PC2, color = factor, alpha = as.numeric(year)),
        x = 0, y = 0,
        arrow = arrow(length = unit(0.1,"cm")), linewidth = 0.3) +
    scale_color_brewer("Variable",palette = "Set3",
        guide = guide_legend(ncol = 2, title.position = "top")) +
    scale_alpha("Year", guide = guide_legend(ncol = 1, title.position = "top")) +
    coord_equal()+
    theme_light(base_size = 6)

a + b + plot_layout(guides = "collect") & 
    theme_light(base_size = 10) &
    theme(legend.position = "bottom") 

# ggsave(
#     filename = "pca_wb-data.png", path = "figures/", dpi = 400, bg = "white",
#     device = "png", width = 7, height = 4,
#     plot = (a + b + plot_layout(guides = "collect") & 
#     theme_light(base_size = 6) &
#     theme(legend.position = "bottom") )
# )

```


- 95% of the variability is explained by the first 10 PCs

For the UN dataset, the area based nature proxies have zero variance (SD), which means that despite completness, it is not informative.


```{r}
##
zero_variance_vars <- df_un_reduced |>
    pivot_longer(3:last_col(), names_to = "variable", values_to = "value") |> 
    mutate(
        year = str_sub(variable, 1L, 4L),
        variable = str_sub(variable, 6L, -1L)
    ) |> # pull(variable) |> unique()
    filter(variable != "sptinc992j_p0p100") |>
    group_by(iso3, variable) |> 
    mutate(variance = var(value)) |>
    filter(variance == 0) |>
    pull(variable) |> unique()

pca2 <- df_un_reduced |>
    ungroup() |> 
    select(-country, -iso3, -NA_NA) |> #skimr::skim()
    select(-contains("sptinc"), -contains("gptinc"), -contains("rptinc")) |> 
    prcomp(center = TRUE, scale. = TRUE)

```
**J230529:** It doesn't work, there is no enough variability in the data. It seems I have several variables / countries with zero variance or constants despite no missing values. However, it only screws up when adding the inequality variables. Without it does still run, why? Check with Maike. It might have to do with number of observations (countries) vs number of variables. Most likely too wide of a dataset can be problematic.

```{r}
biplot(pca2)
```
### Multiple factor analysis

```{r}
mfa1 <- df_un_reduced |> 
    select(-iso3, -country, -NA_NA) |> 
    as.matrix(dimnames = list(df_un_reduced |> pull(iso3) |> unique())) |> 
    FactoMineR::MFA(group = rep(19, 10), type = rep("s", 10)) # 18 years times 6 variables
```

```{r}
mfa1
```

```{r}
mfa1$eig[1:10,2] |> barplot(names = 1:10)

```
```{r}
mfa1$group
```

```{r}
mfa1 |> summary()
```


```{r}
ggbiplot::ggbiplot(
    pca1,
    labels = df_dat |>  select(-country_name, -country, -sptinc992j_p0p100) |> 
    filter(!is.na(rptinc992j_p0p100)) |> pull(country_code) |> unique(),
    circle = TRUE,
    varname.abbrev = TRUE)
```



## To dos:

- one PCA per year, see how PCA1 change over time. 

```{r}
pca3 <- df_dat |> 
    ungroup() |> 
    mutate(year = as_factor(year)) |> 
    split(~year) |>
    map(function(x) select(x, where(is.numeric))) |> 
    map(function(x) princomp(x, center = TRUE, scale. = TRUE))
```

```{r}
pca3 |> map(biplot)
```

## Paper outline

Title: Trade-offs between biosphere goals and inequality at the national scale

Introduction

- Previous studies proposed the hypothesis of the trilemma
- Do the trade-offs hold at national scale with SDG data?

Methods:

- SDG datasets at national scale collected by World Bank and United Nations
- Selection of variables
- Multiple Factor Analysis (PCA over time)
- Clustering

Results:

- 

## Leftovers

Old code, most of the steps outlined are already implemented

```{r}
### World Bank dataset:
# vars is the list of variables with <30% missing values over time and space
# vars2 is the same list for UN dataset
# yrs <- sdg$time_period|> range(na.rm = TRUE) 
# 
# df_wb <- dat |>
#     filter(indicator_name %in% vars, country_code %in% complete_countries) |> 
#     select(-x35) |> 
#     pivot_longer(cols = x1990:last_col(), values_to = "value", names_to = "year") |> 
#     mutate(year = str_remove(year, "x"), year = as.numeric(year)) |> 
#     filter(year >= yrs[1], year <= yrs[2]) |> # use only years available in both datsets
#     rename(iso3 = country_code) |> select(-indicator_code) |> 
#     left_join(
#         select(un_countries, iso3 = `ISO-alpha3 Code`, country_name = `Country or Area`)
#     )
# 
# df_un <- sdg |> 
#     rename(indicator_name = series_description, year = time_period, iso3 =`ISO-alpha3 Code` ) |> 
#     filter(iso3 %in% countries_list, !is.na(value), indicator_name %in% vars2) |>
#     filter(goal %in% c(10, 14, 15)) |> 
#     group_by(indicator_name, year, iso3) |>
#     summarize(mean_val = mean(value, na.rm = TRUE)) |> 
#     ungroup() |> #group_by(indicator_name, year, iso3) |> 
#     # add_count() |> 
#     pivot_wider(names_from = year, values_from = mean_val) |> 
#     pivot_longer(cols = starts_with("2"), names_to = "year", values_to = "value",
#                  names_transform = list(year = as.numeric, value = as.numeric))|> 
#     left_join(
#         select(un_countries, iso3 = `ISO-alpha3 Code`, country_name = `Country or Area`)
#     )
#     
# df_sdg <- full_join(df_un, df_wb) |> 
#     rename(indicator = indicator_name)
# 
# df_sdg |> skimr::skim()
```

```{r}
# df_sdg |> 
#     ggplot(aes(year, value)) +
#     geom_line(aes(group = iso3), show.legend = FALSE) +
#     facet_wrap(~indicator, scales = "free_y")
```
remove countries with too few observations:

```{r}
# tot_vars <- df_sdg |> pull(indicator) |> unique() |> length()
# tot_yrs <- df_sdg |> pull(year) |> unique() |> length()
# tot_cnt <- df_sdg |> pull(iso3) |> unique() |> length()
# 
# df_sdg |> 
#     pivot_wider(names_from = indicator, values_from = value) |> 
#     pivot_longer(cols = 4:last_col(),names_to = "indicator", values_to = "value") |> 
#     mutate(nas = is.na(value)) |>
#     group_by(iso3, indicator) |> 
#     dplyr::summarize(missing = sum(nas)/ (tot_yrs)) |> 
#     summarize(suitable = missing > 0.3) |> 
#     ungroup() |> group_by(iso3) |> 
#     summarize(varsok = sum(suitable)) |> 
#     filter(varsok == tot_vars)
# 
# key_cntrs
```


Impute missing values:

```{r}
# df_sdg <- df_sdg |> 
#     filter(iso3 %in% key_cntrs) |> 
#     pivot_wider(names_from = indicator, values_from = value) |> 
#     pivot_longer(cols = 4:last_col(),names_to = "indicator", values_to = "value") |> 
#     group_by(indicator, iso3) |> 
#     mutate(value = na_interpolation(value, option = "stine"))
```

```{r}
# df_sdg |> 
#     ggplot(aes(year, value)) +
#     geom_line(aes(group = iso3), alpha = 0.5, show.legend = FALSE) +
#     facet_wrap(~indicator, scales = "free_y")
```
Check for correlations:

```{r}
# df_sdg |> 
#     pivot_wider(names_from = indicator, values_from = value) |> 
#     GGally::ggpairs(
#         columns = 4:21 ,
#     lower = list(continuous = GGally::wrap("points", alpha = 0.5, size = 0.5)),
#     diag = list(continuous = GGally::wrap("densityDiag", alpha = 0.2))
#     # upper = list(continuous = GGally::wrap("cor", size = 2))
#     ) + theme_light(base_size = 6)
```


```{r}
# df_sdg <- df_sdg |> 
#     ungroup() |> 
#     pivot_wider(names_from = indicator, values_from = value) |> 
#     mutate(
#         across(.cols = c("Cereal yield (kg per hectare)" ,"Forest area (sq. km)" ,
#             "Forest area certified under an independently verified certification scheme (thousands of hectares)" , "Total assistance for development, by donor countries (millions of current United States dollars)"  , "Total assistance for development, by recipient countries (millions of current United States dollars)"
#         ), .fns = log1p)
#     ) 
```


Paper title: the blind spots of sustainable development

- underscore the fact that a lot of variables are not available
- the kind of variables available are not appropriate in many cases
- sub-national conversation: countries interpret and collect data differently [carla and emmy work]
- what can be done to address the gaps? use of other datasets
- open questions for other SDGs dimensions...